# At the beginning of each track, select the first ready child.
# @category Source / Track processing
# @param ~id Force the value of the source ID.
# @param ~override Metadata field which, if present and containing a float, overrides the `transition_length` parameter.
# @param ~replay_metadata Replay the last metadata of a child when switching to it in the middle of a track.
# @param ~track_sensitive Re-select only on end of tracks.
# @param ~transition_length Maximum transition duration.
# @param ~transitions Transition functions, padded with `fun (x,y) -> y` functions.
def fallback(~id=null(), ~override="liq_transition_length", ~replay_metadata=true,
           ~track_sensitive=getter(true), ~transition_length=5., ~transitions=[],
           sources) =
  def prepare(idx, s) =
    def f(m) =
      [...m, ("fallback_index", "#{idx}")]
    end
    s = metadata.map(f, s)
    insert_metadata(s)
  end

  sources = list.mapi(prepare, sources)

  s = fallback(track_sensitive=track_sensitive, sources)

  if list.length(transitions) != 0 then
    def default_transition(old, new) =
      (sequence([old, new]):source)
    end

    selected = ref(null())

    def transition(old, new) =
      old_idx = int_of_string(default=-1, old.metadata["fallback_index"])
      new_idx = int_of_string(default=-1, new.metadata["fallback_index"])

      if replay_metadata and old_idx != new_idx then
        list.nth(sources, new_idx).insert_metadata(new.metadata)
      end

      transition = list.nth(default=default_transition, transitions, new_idx)

      s = transition(old.source, new.source)

      selected := s

      s
    end

    cross(id=id, duration=transition_length, override_duration=override, transition, s).{selected = fun () -> !selected}
  else
    s
  end
end

# At the beginning of a track, select the first source whose predicate is true.
# @category Source / Track processing
# @param ~id Force the value of the source ID.
# @param ~override Metadata field which, if present and containing a float, overrides the `transition_length` parameter.
# @param ~replay_metadata Replay the last metadata of a child when switching to it in the middle of a track.
# @param ~track_sensitive Re-select only on end of tracks.
# @param ~transition_length Maximum transition duration.
# @param ~transitions Transition functions, padded with `fun (x,y) -> y` functions.
def switch(~id=null(), ~override="liq_transition_length", ~replay_metadata=true,
           ~track_sensitive=getter(true), ~transition_length=5., ~transitions=[],
           sources) =
  sources = list.map(fun(ps) -> source.available(snd(ps), fst(ps)), sources)
  fallback(id=id, override=override, replay_metadata=replay_metadata,
           track_sensitive=track_sensitive, transition_length=transition_length,
           transitions=transitions, sources)
end

let stdlib_fallback = fallback

# Special track insensitive fallback that always skips current song before
# switching.
# @category Source / Track processing
# @flag extra
# @param s The main source.
# @param ~fallback The fallback source.
def fallback.skip(s,~fallback=blank())
  avail = ref(true)
  def check()
    old = !avail
    avail := source.is_ready(s)
    if not old and !avail then
      source.skip(fallback)
    end
  end
  s = stdlib_fallback(track_sensitive=false, [s, fallback])
  # TODO: could we have something more efficient that checking on every frame
  source.on_frame(s, check)
end

# Rotate between sources.
# @category Source / Track processing
# @param ~id Force the value of the source ID.
# @param ~override Metadata field which, if present and containing a float, overrides the `transition_length` parameter.
# @param ~replay_metadata Replay the last metadata of a child when switching to it in the middle of a track.
# @param ~transition_length Maximum transition duration.
# @param ~transitions Transition functions, padded with `fun (x,y) -> y` functions.
# @param ~weights Weights of the children (padded with 1), defining for each child how many tracks are played from it per round, if that many are actually available.
def rotate(~id=null(), ~override="liq_transition_length", ~replay_metadata=true,
           ~transition_length=5., ~transitions=[],
           ~weights=[], sources) =
  weights = list.map(getter.function, weights)
  default_weight = {1}
  failed = (source.fail():source)

  # Currently selected index
  picked_index = ref(-1)

  # Number of tracks played per selected source
  # source IDs can change between calls..
  tracks_played = list.map(fun (s) -> ((fun () -> source.id(s)), ref(0)), sources)
  tracks_played = fun () -> list.map(fun (x) -> begin
    label_fn = fst(x)
    (label_fn(), snd(x))
  end, tracks_played)

  # Find index of next source to play, i.e. first ready source after currently
  # selected one.
  def pick() =
    list.iter((fun (el) -> snd(el) := 0), tracks_played())

    if list.exists(source.is_ready, sources) then
      def rec f(index) =
        s = list.nth(default=failed, sources, index)
        if source.is_ready(s) then
          picked_index := index
        else
          f((index + 1) mod list.length(sources))
        end
      end
      f((!picked_index+1) mod list.length(sources))
    else
      picked_index := -1
    end
  end

  # Add condition to i-th source.
  def add_condition(index, s) =
    def cond() =
      if !picked_index == -1 then pick() end

      if !picked_index != -1 then
        picked_weight = list.nth(default=default_weight, weights, !picked_index)
        picked_source = list.nth(sources, !picked_index)
        if picked_weight () <= !list.assoc(source.id(picked_source), tracks_played()) then
          pick()
        end
      end

      !picked_index == index
    end

    (cond, s)
  end

  s = switch(override=override, replay_metadata=replay_metadata, track_sensitive=true,
             transition_length=transition_length, transitions=transitions,
             list.mapi(add_condition, sources))

  def f(_) =
    if null.defined(s.selected()) then
      selected_id = source.id(null.get(s.selected()))
      if list.assoc.mem(selected_id, tracks_played()) then
        played = list.assoc(selected_id, tracks_played())
        ref.incr(played)
      end
    end
  end

  s = source.on_track(s, f)

  def replaces s =
    fallback(id=id, track_sensitive=true, s::sources)
  end

  s
end

# At the beginning of every track, select a random ready child.
# @category Source / Track processing
# @param ~id Force the value of the source ID.
# @param ~override Metadata field which, if present and containing a float, overrides the `transition_length` parameter.
# @param ~replay_metadata Replay the last metadata of a child when switching to it in the middle of a track.
# @param ~transition_length Maximum transition duration.
# @param ~transitions Transition functions, padded with `fun (x,y) -> y` functions.
# @param ~weights Weights of the children (padded with 1), defining for each child the probability that it is selected.
def replaces random(~id=null(), ~override="liq_transition_length", ~replay_metadata=true,
           ~transition_length=5., ~transitions=[],
           ~weights=[], sources) =
  weights = list.map(getter.function, weights)
  default_weight = fun () -> 1
  next_index = ref(-1)

  def pick() =
    def available_weighted_sources(cur, s) =
      let (index, current_weight, indexes) = cur
      weight = list.nth(default=default_weight, weights, index)

      let (current_weight, indexes) =
        if source.is_ready(s) then
          weight = weight()
          indexes = (current_weight, current_weight+weight, index) :: indexes
          (current_weight + weight, indexes)
        else
          (current_weight, indexes)
        end

      (index+1, current_weight, indexes)
    end

    let (_, total_weight, weighted_indexes)  =
      list.fold(available_weighted_sources, (0, 0, []), sources)

    picked_weight =
      if total_weight > 0 then
        random.int(min=0, max=total_weight)
      else
        0
      end

    def pick_source(picked_index, el) =
      let (lower_bound, upper_bound, index) = el

      if lower_bound <= picked_weight and picked_weight < upper_bound then
        index
      else
         picked_index
      end
    end

    next_index := list.fold(pick_source, -1, weighted_indexes)
  end

  def add_condition(index, s) =
    def cond() =
      if !next_index == -1 then pick() end
      !next_index == index
    end

    (cond, s)
  end

  s = switch(override=override, replay_metadata=replay_metadata, track_sensitive=true,
             transition_length=transition_length, transitions=transitions,
             list.mapi(add_condition, sources))

  def f(_) =
    next_index := -1
  end

  s = source.on_track(s, f)

  def replaces s =
    fallback(id=id, track_sensitive=true, s::sources)
  end

  s
end
